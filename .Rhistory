mifuncion <- function[] {
x <- rnorm(100)
mean(x)}
dir()
source ("prueba.R")
ls
ls
ls
cls
source("mifuncion")
prueba.R
source("prueba.R")
second (4)
ls
x <-5
x
x <- factor(c("si","si","no","si","no")), levels = c("si","no")
x <- factor(c("si","si","no","si","no"), levels = c("si","no"))
x
x <- factor(c("si","si","no","si","no"))
x
q()
r<-c(T,F)
r
r<-c(T,F,T,T)
r
t<-9:29
t
q<-c("alumno", "direccion","estado")
q
q<-c("alumno", "direccion",estado)
q<-c("alumno", "direccion","estado")
q
w<-vector("character",legth=5)
w<-vector("integer",legth=5)
w<-vector("number",legth=5)
w<-vector("numeric",legth=5)
w<-vector("character",length=5)
w
w<-vector("numeric",length=5)
w
w<-vector("number",length=5)
j<-list(4,"d",T,1+4i)
j
j<-list(4,"d",T,1+4i;1,2,3,4)
j<-list(4,"d",T,1+4i:1,2,3,4)
j<-list(4,"d",T,1:1,2,3,4)
j<-list(4,"d",T,1:1,2,3,4)
j
j<-list(4,"d",T,1+4i)
j
j<-list(4,"d",T,1+4i,(1:5))
j
q()
msg<-"hello"
print(msg)
c<-56.23
print c
print(c)
help(print)
cls
clear
#es un comentario
c
y<- 1:2:20
y<- 1:20
y
y<- 1;2;20
y<- 1,2,20
y<- 1:1:20
y
y<- 2:2:20
y
y<- 1:2:20
vector()
d<-vector()
d
f<-1
f<-1L
f
f<-1
f
1/Inf
attributes(f)
attributes(msg)
attributes("msg")
attributes(y)
getwd()
getwd()
mifuncion <- function{} {
x <- rnorm(100)
mean(x)}
mifuncion <- function{} {
x <- rnorm(100)
mean(x)}
mifuncion <- function[] {
x <- rnorm(100)
mean(x)}
dir()
source ("prueba.R")
ls
ls
ls
cls
source("mifuncion")
prueba.R
source("prueba.R")
second (4)
ls
x <-5
x
x <- factor(c("si","si","no","si","no")), levels = c("si","no")
x <- factor(c("si","si","no","si","no"), levels = c("si","no"))
x
x <- factor(c("si","si","no","si","no"))
x
q()
r<-c(T,F)
r
r<-c(T,F,T,T)
r
t<-9:29
t
q<-c("alumno", "direccion","estado")
q
q<-c("alumno", "direccion",estado)
q<-c("alumno", "direccion","estado")
q
w<-vector("character",legth=5)
w<-vector("integer",legth=5)
w<-vector("number",legth=5)
w<-vector("numeric",legth=5)
w<-vector("character",length=5)
w
w<-vector("numeric",length=5)
w
w<-vector("number",length=5)
j<-list(4,"d",T,1+4i)
j
j<-list(4,"d",T,1+4i;1,2,3,4)
j<-list(4,"d",T,1+4i:1,2,3,4)
j<-list(4,"d",T,1:1,2,3,4)
j<-list(4,"d",T,1:1,2,3,4)
j
j<-list(4,"d",T,1+4i)
j
j<-list(4,"d",T,1+4i,(1:5))
j
q()
y
f<-2:10
f
prit(f)
print(f)
h<-("d",TRUE,5)
h<-("d",2,TRUE,5)
h<-(2,TRUE,5,"d")
h<-(TRUE,5,"d")
h<-c("d",2,TRUE,5)
h
class(h)
h<-(TRUE,5,"d")
h<-j(TRUE,5,"d")
h<-c(TRUE,5,"d")
class(h)
y<-list(1,"a",T,(2:6))
y
m
m<-matrix(2,3;4,5)
m<-matrix(2,3)
m
m<-(2,3,5)
m<-c(2,3,5)
n<-c(6,7,9)
rbind(m,n)
q()
if (x<-3){y<-10}
else {y<-0}
if (x<-3){y<-10} else {y<-0}
pplot.xy()
plot(x,y)
for(i in 1:2:100){print (i)}
x<-c("a","b","c")
for (i in 1:3){print x[i]}
for (i in 1:3){print (x[i])}
for (i in seq_along(x)){print(x[i])}
for (letter in x){print(letter)}
x<-matrix(1:6)
x<-matrix(1:6,2,3)
for (in in seq_along(nrow(x)))      {for j in seq_along(ncol(x))}    print{x[i,j]}
for (in in seq_along(nrow(x)))      {for j in seq_along(ncol(x))      print{x[i,j]}}
for (in in seq_along(nrow(x)))      {for j in seq_along(ncol(x))      print(x[i,j])}
for (i in seq_along(nrow(x)))      {for j in seq_along(ncol(x))      print(x[i,j])}
for (i in seq_len(nrow(x)))      {for j in seq_len(ncol(x))      print(x[i,j])}
for (i in seq_len(nrow(x)))      {for j in seq_len(ncol(x))      {print(x[i,j])}}
for (i in seq_len(nrow(x)))      {for (j in seq_len(ncol(x)))      {print(x[i,j])}}
count<-1
while (count<10{print (count)})
while (count<10{print (count)}) count<-count+1}
while (count<10{print (count)) count<-count+1}
while (count<10){print (count)) count<-count+1}
while (count<10){print (count) count<-count+1}
count<-count+1}
count<-0
count<-0
count<-0
count<-1
count<-1
source('C:/Users/ALGABER/Desktop/CourseraR/Problemas/Week2/Mientras.R')
x<-5
y<- if (x<3){NA} else {10}
y
cube<- function(x,n){x^3}
cube(3)
x<-1:10
if(x>5){x<-0}
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
f <- function(x) {  g <- function(y) {   y + z    }   z <- 4    x + g(x)}
f <- function(x) {  g <- function(y) {   y + z    }   z<- 4    x + g(x)}
?L
??L
??L
help.search("L")
add2<-function(x,y){
x+y
}
add2(2,3)
above<-function(x,n){
above<-function(x,n){
use<-x>n
x[use]
}
x<-1:20
above(x,12)
columnmean<-function(y){
nc<-ncol(y) #asigno el numero de columnaS a la
#variable nc
means <- numeric(nc) # asignacion a means del
#un vector numerico nc
for(i in 1:nc){
means[i]<-mean(y[,i])
}
columnmean<-function(y){
nc<-ncol(y) #asigno el numero de columnaS a la
#variable nc
means <- numeric(nc) # asignacion a means del
#un vector numerico nc
for(i in 1:nc){
means[i]<-mean(y[,i])
}
means
}
columnmean(airquality)
airquality
columnmean<-function(y,removeNA = T){
nc<-ncol(y) #asigno el numero de columnaS a la
#variable nc
means <- numeric(nc) # asignacion a means del
#un vector numerico nc
for(i in 1:nc){
means[i]<-mean(y[,i],na.rm = removeNA)
#na.rm Elimina los terminos NA
}
means
}
columnmean(airquality)
lm<-function(x){x*x}
lm
lm(3)
search()
c<-2
c
v<-c("b",2,T,4)
v
make.power<-function(n{})
make.power<-function(n){
pow<-function(x){
x^n
}
pow
}
cube<-make.power(3)
square<-make.power(2)
cube(3)
square(3)
make.power<-function(n){
pow<-function(x){
x^n
}
pow
}
make.power<-function(n){
pow<-function(x){
x^n
}
pow
}
means[i]<-mean(y[,i],na.rm = removeNA)
#na.rm Elimina los terminos NA
}
means
columnmean<-function(y,removeNA = T){
nc<-ncol(y) #asigno el numero de columnaS a la
#variable nc
means <- numeric(nc) # asignacion a means del
#un vector numerico nc
for(i in 1:nc){
means[i]<-mean(y[,i],na.rm = removeNA)
#na.rm Elimina los terminos NA
}
means
}
?Sys.glob
# Write a function that takes a directory of data files and a threshold for complete
# cases and calculates the correlation between sulfate and nitrate for monitor locations
# where the number of completely observed cases (on all variables) is greater than the
# threshold. The function should return a vector of correlations for the monitors that
# meet the threshold requirement. If no monitors meet the threshold requirement, then
# the function should return a numeric vector of length 0. A prototype of this function
# follows
corr <- function(directory, threshold = 0) {
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'threshold' is a numeric vector of length 1 indicating the
## number of completely observed observations (on all
## variables) required to compute the correlation between
## nitrate and sulfate; the default is 0
files <- (Sys.glob("specdata/*.csv"));
correlations <- c()
for (file in files) {
file_data <- read.csv(file, sep = ",");
complete_cases <- file_data[complete.cases(file_data),];
if (nrow(complete_cases) > threshold) {
correlations <- c(correlations, cor(complete_cases$sulfate, complete_cases$nitrate))
}
}
return(correlations)
}
source('C:/Users/ALGABER/Desktop/CourseraR/Problemas/Week2/corr.R')
cr<-corr("specdata",150)
head(cr)
source('C:/Users/ALGABER/Desktop/CourseraR/Problemas/Week2/corr.R')
cr<-corr("specdata",150)
head(cr)
cr<-corr("specdata",0)
head(cr)
source('C:/Users/ALGABER/Desktop/CourseraR/Problemas/Week2/corr.R')
cr<-corr("specdata",0)
head(cr)
source('C:/Users/ALGABER/Desktop/CourseraR/Problemas/Week2/corr.R', encoding = 'ASCII')
source('C:/Users/ALGABER/Desktop/CourseraR/Problemas/Week2/corr.R', encoding = 'ASCII')
cr<-corr("specdata",150)
head(cr)
source('C:/Users/ALGABER/Desktop/CourseraR/Problemas/Week2/corr.R', encoding = 'ASCII')
source('C:/Users/ALGABER/Desktop/CourseraR/Problemas/Week2/corr.R', encoding = 'ASCII', echo=TRUE)
source('C:/Users/ALGABER/Desktop/CourseraR/Problemas/Week2/corr.R', encoding = 'ASCII', echo=TRUE)
source('C:/Users/ALGABER/Desktop/CourseraR/Problemas/Week2/corr.R', encoding = 'ASCII')
source('C:/Users/ALGABER/Desktop/CourseraR/Problemas/Week2/corr.R', encoding = 'ASCII')
?solve
source('C:/Users/ALGABER/ProgrammingAssignment2/cachematrix.R')
makeCacheMatrix(x)
source('C:/Users/ALGABER/ProgrammingAssignment2/cachematrix.R')
source('C:/Users/ALGABER/ProgrammingAssignment2/cachematrix.R')
source('C:/Users/ALGABER/ProgrammingAssignment2/cachematrix.R')
source('C:/Users/ALGABER/ProgrammingAssignment2/cachematrix.R')
source('C:/Users/ALGABER/ProgrammingAssignment2/cachematrix.R')
h<-(2,1,5,3)
?"matrix"
h <- matrix(2,1,5,3, nrow = 2, ncol = 2)
h <- matrix(2,1,5,3, nrow = 2, ncol = 2)
h<-null
h<-matrix()
h
h[1,1]<_2
h[1,1]<-2
h
h[1,2]<-1
h[2,2]<-3
x<-c(2,5)
y<-c(1,3)
h<-cbind(x,y)
h
class(h)
cacheSolve(h)
makeCacheMatrix(h)
cacheSolve(h)
cacheSolve(h)
cacheSolve(h)
test = function(mat){
## @mat: an invertible matrix
temp = makeCacheMatrix(mat)
start.time = Sys.time()
cacheSolve(temp)
dur = Sys.time() - start.time
print(dur)
start.time = Sys.time()
cacheSolve(temp)
dur = Sys.time() - start.time
print(dur)
}
set.seed(1110201)
r = rnorm(1000000)
mat1 = matrix(r, nrow=1000, ncol=1000)
test(mat1)
source('C:/Users/ALGABER/ProgrammingAssignment2/cachematrix.R')
cacheSolve(h)
makeCacheMatrix(h)
test = function(mat){
## @mat: an invertible matrix
temp = makeCacheMatrix(mat)
start.time = Sys.time()
cacheSolve(temp)
dur = Sys.time() - start.time
print(dur)
start.time = Sys.time()
cacheSolve(temp)
dur = Sys.time() - start.time
print(dur)
}
set.seed(1110201)
r = rnorm(1000000)
mat1 = matrix(r, nrow=1000, ncol=1000)
test(mat1)
makeCacheMatrix(h)
h
m
y
makeCacheMatrix(h)
temp<-makeCacheMatrix(h)
cacheSolve(temp)
source('C:/Users/ALGABER/ProgrammingAssignment2/cachematrix.R')
makeCacheMatrix(h)
cacheSolve(h)
source('C:/Users/ALGABER/ProgrammingAssignment2/cachematrix.R')
cacheSolve(h)
source('C:/Users/ALGABER/ProgrammingAssignment2/cachematrix.R')
makeCacheMatrix(h)
temp<-makeCacheMatrix(h)
cacheSolve(h)
> temp<-makeCacheMatrix(h)
> cacheSolve(temp)
> temp<-makeCacheMatrix(h)+ cacheSolve(temp)
temp<-makeCacheMatrix(h)+ cacheSolve(temp)
cacheSolve(h)
makeCacheMatrix(h)
h
>cacheSolve(H)
cacheSolve(h)
## The following functions compute and cache the inverse matrix. It able to reduce
## the computation time compared to calculation with loops.
#La primera funcion crea una matrix especial para almacenar en cache
#Segunda funcion coge la matrix anterior y checks si ha sido calculada
#si es asi coge el resultado de cache sino la calcula y pone el resuldo en cache
## Write a short comment describing this function
##
## The operators <<- and ->> are normally only used in functions, and cause a search
## to made through parent environments for an existing definition of the variable
## being assigned. If such a variable is found (and its binding is not locked)
## then its value is redefined
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
# y debe ser la matrix en cache?
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse)
m <<- inverse
getinverse <- function()
m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
m.data <- x$get()
m <- solve(m.data, ...)
x$setinverse(m)
m
}
cacheSolve(h)
cacheSolve(makeCacheMatrix(h))
cacheSolve(makeCacheMatrix(h))
setwd("C:/Users/ALGABER/ProgrammingAssignment2")
oops<-makeCacheMatrix(h)
cacheSolve(oops)
cacheSolve(oops)
oops$get()
oops$getinverse()
oops$set(matrix(c(3,-1,-5,2),nrow = 2,byrow = T))
oops$getinverse()
cacheSolve(oops)
source('C:/Users/ALGABER/ProgrammingAssignment2/cachematrix.R')
oops$set(matrix(c(3,-1,-5,2),nrow = 2,byrow = T))
oops<-makeCacheMatrix(h)
oops$set()
oops$set(matrix(c(3,-1,-5,2),nrow = 2,byrow = T))
source('C:/Users/ALGABER/ProgrammingAssignment2/cachematrix.R')
